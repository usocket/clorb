(setf token-list (let*     ((nl (coerce '(#\newline #\return) 'string))      (digits '(+ digit))      (int-literal `(seq ("123456789") (* ,digits)))      (oct-literal '(seq "0" (* oct-digit)))      (hex-literal '(seq (or "0x" "0X") (+ hex-digit)))      (esc-sequence1 '(seq #\\ "ntvbrfa\\???'\""))      (esc-sequence2 '(seq #\\ (or oct-digit (seq oct-digit oct-digit oct-digit))))      (esc-sequence3 '(seq #\\ ("xX") hex-digit (? hex-digit)))      (esc-sequence `(or ,esc-sequence1 ,esc-sequence2 ,esc-sequence3))      (char         `(or (^ #\newline #\tab #\" #\' #\\) ,esc-sequence))      (char-literal    `(seq #\' (or ,char #\" ) #\'))      (string-literal '(seq "'" (* (^ "'")) "'"))      (string-literal1 '(seq "\"" (* (^ "\"")) "\""))      (Float-Literal1 `(seq ,digits "." (? ,Digits) ("eE") ("+-") ,Digits))        (Float-Literal2 `(seq ,Digits ("eE") ("+-") ,Digits))      (Float-Literal3 `(seq ,Digits "." ,Digits))      (Float-Literal4 `(seq ,digits "."))      (Float-Literal5 `(seq "." ,Digits))      (Float-Literal6 `(seq "." ,Digits ("eE") ("+-") ,digits))      (Fixed-Literal1 `(seq ,Digits ("dD")))      (Fixed-Literal2 `(seq ,Digits "." ("dD")))      (Fixed-Literal3 `(seq "." ,Digits ("dD")))      (Fixed-Literal4 `(seq ,Digits "." ,Digits "dD"))      (leer '(+ (or #\tab #\space #\newline #\return)))      (CORBA-Identifier `(seq alpha (* (or alpha-num ("_")))))      (comment `(or (seq "//" (^ #\newline) ,nl) 		   (seq "/*" (* (or (seq "*" (^ "/")) (^ "*")) "*/"))))      (comment1 `(seq "/*" 		    (* (or (seq "*" (^ "/")) 			   (^ "*"))) 		    "*/"))      (comment2 `(seq "//" (* (^ #\newline #\return)) (or #\newline #\return)))      (pragma `(seq "#" (* (^ #\newline #\return)) (or #\newline #\return))))         `((,leer leer)     ;(,comment 'comment)     (,pragma pragma)      (,comment1 comment1)     (,comment2 comment2)     ("{" T_LEFT_CURLY_BRACKET)     ("}" T_RIGHT_CURLY_BRACKET)     ("[" T_LEFT_SQUARE_BRACKET)     ("]" T_RIGHT_SQUARE_BRACKET)     ("(" T_LEFT_PARANTHESIS)     (")" T_RIGHT_PARANTHESIS)     (":" T_COLON)     ("," T_COMMA)     (";" T_SEMICOLON)     ("=" T_EQUAL)     (">>" T_SHIFTRIGHT)     ("<<" T_SHIFTLEFT)     ("+" T_PLUS_SIGN)     ("-" T_MINUS_SIGN)     ("*" T_ASTERISK)     ("/" T_SOLIDUS)     ("%" T_PERCENT_SIGN)     ("~" T_TILDE)     ("|" T_VERTICAL_LINE)     ("^" T_CIRCUMFLEX)     ("&" T_AMPERSAND)     ("<" T_LESS_THAN_SIGN)     (">" T_GREATER_THAN_SIGN)          ("const"         T_CONST)     ("typedef"	      T_TYPEDEF)     ("float"	      T_FLOAT)     ("double"	      T_DOUBLE)     ("char"	      T_CHAR)     ("wchar"	      T_WCHAR)     ("fixed"         T_FIXED)     ("boolean"	      T_BOOLEAN)     ("string"	      T_STRING)     ("wstring"	      T_WSTRING)     ("void"	      T_VOID)     ("unsigned"      T_UNSIGNED)     ("long" 	      T_LONG)     ("short"	      T_SHORT)     ("FALSE"	      T_FALSE)     ("TRUE"	      T_TRUE)     ("struct"	      T_STRUCT)     ("union"	      T_UNION)     ("switch"	      T_SWITCH)     ("case"	      T_CASE)     ("default"	      T_DEFAULT)     ("enum"	      T_ENUM)     ("in"	      T_IN)     ("out"	      T_OUT)     ("interface"     T_INTERFACE)     ("abstract"      T_ABSTRACT)     ("valuetype"     T_VALUETYPE)     ("truncatable"   T_TRUNCATABLE)     ("supports"      T_SUPPORTS)     ("custom"	      T_CUSTOM)     ("public"	      T_PUBLIC)     ("private"	      T_PRIVATE)     ("factory"	      T_FACTORY)     ("native"	      T_NATIVE)     ("ValueBase"     T_VALUEBASE)       	     ("::" T_SCOPE)       	     ("module"	  T_MODULE)     ("octet"	  T_OCTET)     ("any"	  T_ANY)     ("sequence"  T_SEQUENCE)     ("readonly"  T_READONLY)     ("attribute" T_ATTRIBUTE)     ("exception" T_EXCEPTION)     ("oneway"	  T_ONEWAY)     ("inout"	  T_INOUT)     ("raises"	  T_RAISES)     ("context"	  T_CONTEXT)       	     ("Object"    T_OBJECT)     ("Principal" T_PRINCIPAL)       	       	     ((or ,Float-Literal1 	  ,Float-Literal2 		  ,Float-Literal3	  ,Float-Literal4	  ,Float-Literal5	  ,Float-Literal6) T_FLOATING_PT_LITERAL)          ((or ,Fixed-Literal1	  ,Fixed-Literal2	  ,fixed-Literal3	  ,Fixed-Literal4) T_FIXED_PT_LITERAL)     (,int-literal t_integer_literal)     (,oct-literal t_integer_literal)     (,hex-literal t_integer_literal)     (,char-literal t_character_literal)     (,string-literal t_string_literal)     (,string-literal1 t_string_literal)     (,corba-identifier T_IDENTIFIER))))(load "nfa-compiler.lisp")(load "scanner-generator.lisp")(load "scanner-support.lisp")(use-package :scanner-support)(defvar start)(defvar ta)(defvar ac)(multiple-value-setq (start ta ac) (lexer-spec->table+actions token-list nil))(setf ac (eval (cons 'vector (map 'list (lambda (x) (if (symbolp x) (list 'quote x) x)) ac))))(setf scanner (make-scanner ta ac start (make-line-reader (open "workflow.txt"))))(do ((token (funcall scanner) (funcall scanner))) ((not token)) (pprint token)) stop;(pprint ta);(pprint ac)jjjj'(setf token-list '(( "oneway"	  'T_ONEWAY)		    ( "inout"	  'T_INOUT)		    ( "raises"	  'T_RAISES)		    ( "context"	  'T_CONTEXT)))(defun stream->string (s)  (let ((l nil))    (do ((c (read-char s nil nil nil) (read-char s nil nil nil)))	((not c) (coerce (reverse l) 'string))      (push c l))))(defun file->string (name)  (stream->string (open name :direction :input)))    (defvar b)(setf b (make-string-nexter "asjhdgksaj \"abcd\"  bla")) ;  (setf b (make-string-nexter (file->string "/home/averkamp/clorb-0.2a/lisp/time.idl"))) (time (let (tok str (p 0))   (block otto     (loop       (multiple-value-setq (tok str p) (next-token ta start b p))       (unless str (return-from otto 1))))));       '(pprint (list tok (aref ac tok) str p)))))) sss(let* (       (nl (coerce '(#\newline #\return) 'string))       (comment `(or (seq "//" (^ #\newline) ,nl)		     (seq "/*" (* (or (seq "*" (^ "/")) (^ "*")) "*/"))))       (comment1 `(seq "/*" 		       (* (or (seq "*" (^ "/")) 			      (^ "*"))) 		       "*/"))       (comment2 `(seq "//" (* (^ #\newline #\return)) (or #\newline #\return)))       (a (exported-make-nfa 256)))  (sexp->subnfa a `(or ,comment ,comment1 ,comment2) nil))