;;; idef-macros --- interface definition macros

(in-package :clorb)


;;;; A Global Repository

(defvar *idef-repository*
    (make-instance 'repository))

(add-repository *internal-interface-repository* '*idef-repository*)

(defun lookup-name (name)
  (lookup-name-in *idef-repository* name))

(defmethod gen-idef ((name string))
  (gen-idef (lookup-name name)))


;;;; Macro for IDEF definitions

(defmacro idef-definitions (&body forms)
  `(idef-read ',forms *idef-repository*))

(defmacro idef-code (&body forms)
  (let ((repository (make-instance 'repository)))
    (idef-read forms repository)
    (let* ((target (make-instance 'all-target))
           (code (target-code repository target)))
      (make-progn*
       (make-progn
        (loop for package in (slot-value target 'packages)
              unless (member package *stub-code-ignored-packages*)
              collect (make-target-ensure-package package target)))
       code))))
      

;;;; Creating a servant class

(defmacro define-servant (name scoped-name &key id)
  "Creates an auto-servant class for an interface.
This class can be used almost as a skeleton class generated by an
IDL-compiler."
  `(progn
     (defclass ,NAME (auto-servant)
       ())
     ,@(if id 
           `((defmethod servant-interface-id ((servant ,name))
              ,id)))
     (defmethod servant-interface ((servant ,name))
       (or (ignore-errors (lookup-name ,scoped-name))
           (call-next-method)))))


(defmacro require-idl (name &key file)
  `(eval-when (:load-toplevel :execute)
     (unless (lookup-name-in *idef-repository* ,name nil)
       (load ,file))))
